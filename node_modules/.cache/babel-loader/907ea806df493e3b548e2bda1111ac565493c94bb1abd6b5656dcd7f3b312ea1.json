{"ast":null,"code":"import Autolinker from 'autolinker';\n\n// Autoconvert URL-like texts to links\n\nvar LINK_SCAN_RE = /www|@|\\:\\/\\//;\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n// Stupid fabric to avoid singletons, for thread safety.\n// Required for engines like Nashorn.\n//\nfunction createLinkifier() {\n  var links = [];\n  var autolinker = new Autolinker({\n    stripPrefix: false,\n    url: true,\n    email: true,\n    replaceFn: function replaceFn(match) {\n      // Only collect matched strings but don't change anything.\n      switch (match.getType()) {\n        /*eslint default-case:0*/\n        case 'url':\n          links.push({\n            text: match.matchedText,\n            url: match.getUrl()\n          });\n          break;\n        case 'email':\n          links.push({\n            text: match.matchedText,\n            // normalize email protocol\n            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')\n          });\n          break;\n      }\n      return false;\n    }\n  });\n  return {\n    links: links,\n    autolinker: autolinker\n  };\n}\nfunction parseTokens(state) {\n  var i,\n    j,\n    l,\n    tokens,\n    token,\n    text,\n    nodes,\n    ln,\n    pos,\n    level,\n    htmlLinkLevel,\n    blockTokens = state.tokens,\n    linkifier = null,\n    links,\n    autolinker;\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') {\n      continue;\n    }\n    tokens = blockTokens[j].children;\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n\n      // Skip content of markdown links\n      if (token.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (token.type === 'htmltag') {\n        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(token.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) {\n        continue;\n      }\n      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {\n        // Init linkifier in lazy manner, only if required.\n        if (!linkifier) {\n          linkifier = createLinkifier();\n          links = linkifier.links;\n          autolinker = linkifier.autolinker;\n        }\n        text = token.content;\n        links.length = 0;\n        autolinker.link(text);\n        if (!links.length) {\n          continue;\n        }\n\n        // Now split string to nodes\n        nodes = [];\n        level = token.level;\n        for (ln = 0; ln < links.length; ln++) {\n          if (!state.inline.validateLink(links[ln].url)) {\n            continue;\n          }\n          pos = text.indexOf(links[ln].text);\n          if (pos) {\n            nodes.push({\n              type: 'text',\n              content: text.slice(0, pos),\n              level: level\n            });\n          }\n          nodes.push({\n            type: 'link_open',\n            href: links[ln].url,\n            title: '',\n            level: level++\n          });\n          nodes.push({\n            type: 'text',\n            content: links[ln].text,\n            level: level\n          });\n          nodes.push({\n            type: 'link_close',\n            level: --level\n          });\n          text = text.slice(pos + links[ln].text.length);\n        }\n        if (text.length) {\n          nodes.push({\n            type: 'text',\n            content: text,\n            level: level\n          });\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n      }\n    }\n  }\n}\nfunction linkify(md) {\n  md.core.ruler.push('linkify', parseTokens);\n}\nexport { linkify };","map":{"version":3,"names":["Autolinker","LINK_SCAN_RE","isLinkOpen","str","test","isLinkClose","createLinkifier","links","autolinker","stripPrefix","url","email","replaceFn","match","getType","push","text","matchedText","getUrl","getEmail","replace","parseTokens","state","i","j","l","tokens","token","nodes","ln","pos","level","htmlLinkLevel","blockTokens","linkifier","length","type","children","content","link","inline","validateLink","indexOf","slice","href","title","concat","linkify","md","core","ruler"],"sources":["D:/github/editor.io/node_modules/remarkable/dist/esm/linkify.js"],"sourcesContent":["import Autolinker from 'autolinker';\r\n\r\n// Autoconvert URL-like texts to links\r\n\r\n\r\nvar LINK_SCAN_RE = /www|@|\\:\\/\\//;\r\n\r\n\r\nfunction isLinkOpen(str) {\r\n  return /^<a[>\\s]/i.test(str);\r\n}\r\nfunction isLinkClose(str) {\r\n  return /^<\\/a\\s*>/i.test(str);\r\n}\r\n\r\n// Stupid fabric to avoid singletons, for thread safety.\r\n// Required for engines like Nashorn.\r\n//\r\nfunction createLinkifier() {\r\n  var links = [];\r\n  var autolinker = new Autolinker({\r\n    stripPrefix: false,\r\n    url: true,\r\n    email: true,\r\n    replaceFn: function (match) {\r\n      // Only collect matched strings but don't change anything.\r\n      switch (match.getType()) {\r\n        /*eslint default-case:0*/\r\n        case 'url':\r\n          links.push({\r\n            text: match.matchedText,\r\n            url: match.getUrl()\r\n          });\r\n          break;\r\n        case 'email':\r\n          links.push({\r\n            text: match.matchedText,\r\n            // normalize email protocol\r\n            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')\r\n          });\r\n          break;\r\n      }\r\n      return false;\r\n    }\r\n  });\r\n\r\n  return {\r\n    links: links,\r\n    autolinker: autolinker\r\n  };\r\n}\r\n\r\n\r\nfunction parseTokens(state) {\r\n  var i, j, l, tokens, token, text, nodes, ln, pos, level, htmlLinkLevel,\r\n      blockTokens = state.tokens,\r\n      linkifier = null, links, autolinker;\r\n\r\n  for (j = 0, l = blockTokens.length; j < l; j++) {\r\n    if (blockTokens[j].type !== 'inline') { continue; }\r\n    tokens = blockTokens[j].children;\r\n\r\n    htmlLinkLevel = 0;\r\n\r\n    // We scan from the end, to keep position when new tags added.\r\n    // Use reversed logic in links start/end match\r\n    for (i = tokens.length - 1; i >= 0; i--) {\r\n      token = tokens[i];\r\n\r\n      // Skip content of markdown links\r\n      if (token.type === 'link_close') {\r\n        i--;\r\n        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {\r\n          i--;\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Skip content of html tag links\r\n      if (token.type === 'htmltag') {\r\n        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {\r\n          htmlLinkLevel--;\r\n        }\r\n        if (isLinkClose(token.content)) {\r\n          htmlLinkLevel++;\r\n        }\r\n      }\r\n      if (htmlLinkLevel > 0) { continue; }\r\n\r\n      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {\r\n\r\n        // Init linkifier in lazy manner, only if required.\r\n        if (!linkifier) {\r\n          linkifier = createLinkifier();\r\n          links = linkifier.links;\r\n          autolinker = linkifier.autolinker;\r\n        }\r\n\r\n        text = token.content;\r\n        links.length = 0;\r\n        autolinker.link(text);\r\n\r\n        if (!links.length) { continue; }\r\n\r\n        // Now split string to nodes\r\n        nodes = [];\r\n        level = token.level;\r\n\r\n        for (ln = 0; ln < links.length; ln++) {\r\n\r\n          if (!state.inline.validateLink(links[ln].url)) { continue; }\r\n\r\n          pos = text.indexOf(links[ln].text);\r\n\r\n          if (pos) {\r\n            nodes.push({\r\n              type: 'text',\r\n              content: text.slice(0, pos),\r\n              level: level\r\n            });\r\n          }\r\n          nodes.push({\r\n            type: 'link_open',\r\n            href: links[ln].url,\r\n            title: '',\r\n            level: level++\r\n          });\r\n          nodes.push({\r\n            type: 'text',\r\n            content: links[ln].text,\r\n            level: level\r\n          });\r\n          nodes.push({\r\n            type: 'link_close',\r\n            level: --level\r\n          });\r\n          text = text.slice(pos + links[ln].text.length);\r\n        }\r\n        if (text.length) {\r\n          nodes.push({\r\n            type: 'text',\r\n            content: text,\r\n            level: level\r\n          });\r\n        }\r\n\r\n        // replace current node\r\n        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction linkify(md) {\r\n  md.core.ruler.push('linkify', parseTokens);\r\n}\r\n\r\nexport { linkify };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}