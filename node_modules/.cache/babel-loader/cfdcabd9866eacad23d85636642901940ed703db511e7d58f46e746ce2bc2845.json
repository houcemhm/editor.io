{"ast":null,"code":"import { alphaCharsStr } from \"../regex-lib\";\n/**\r\n * @private\r\n * @class Autolinker.matcher.UrlMatchValidator\r\n * @singleton\r\n *\r\n * Used by Autolinker to filter out false URL positives from the\r\n * {@link Autolinker.matcher.Url UrlMatcher}.\r\n *\r\n * Due to the limitations of regular expressions (including the missing feature\r\n * of look-behinds in JS regular expressions), we cannot always determine the\r\n * validity of a given match. This class applies a bit of additional logic to\r\n * filter out any false positives that have been matched by the\r\n * {@link Autolinker.matcher.Url UrlMatcher}.\r\n */\nvar UrlMatchValidator = /** @class */function () {\n  function UrlMatchValidator() {}\n  /**\r\n   * Determines if a given URL match found by the {@link Autolinker.matcher.Url UrlMatcher}\r\n   * is valid. Will return `false` for:\r\n   *\r\n   * 1) URL matches which do not have at least have one period ('.') in the\r\n   *    domain name (effectively skipping over matches like \"abc:def\").\r\n   *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')\r\n   * 2) URL matches which do not have at least one word character in the\r\n   *    domain name (effectively skipping over matches like \"git:1.0\").\r\n   *    However, URL matches with a protocol will be allowed (ex: 'intra-net://271219.76')\r\n   * 3) A protocol-relative url match (a URL beginning with '//') whose\r\n   *    previous character is a word character (effectively skipping over\r\n   *    strings like \"abc//google.com\")\r\n   *\r\n   * Otherwise, returns `true`.\r\n   *\r\n   * @param {String} urlMatch The matched URL, if there was one. Will be an\r\n   *   empty string if the match is not a URL match.\r\n   * @param {String} protocolUrlMatch The match URL string for a protocol\r\n   *   match. Ex: 'http://yahoo.com'. This is used to match something like\r\n   *   'http://localhost', where we won't double check that the domain name\r\n   *   has at least one '.' in it.\r\n   * @return {Boolean} `true` if the match given is valid and should be\r\n   *   processed, or `false` if the match is invalid and/or should just not be\r\n   *   processed.\r\n   */\n  UrlMatchValidator.isValid = function (urlMatch, protocolUrlMatch) {\n    if (protocolUrlMatch && !this.isValidUriScheme(protocolUrlMatch) || this.urlMatchDoesNotHaveProtocolOrDot(urlMatch, protocolUrlMatch) ||\n    // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n    this.urlMatchDoesNotHaveAtLeastOneWordChar(urlMatch, protocolUrlMatch) &&\n    // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n    !this.isValidIpAddress(urlMatch) ||\n    // Except if it's an IP address\n    this.containsMultipleDots(urlMatch)) {\n      return false;\n    }\n    return true;\n  };\n  UrlMatchValidator.isValidIpAddress = function (uriSchemeMatch) {\n    var newRegex = new RegExp(this.hasFullProtocolRegex.source + this.ipRegex.source);\n    var uriScheme = uriSchemeMatch.match(newRegex);\n    return uriScheme !== null;\n  };\n  UrlMatchValidator.containsMultipleDots = function (urlMatch) {\n    var stringBeforeSlash = urlMatch;\n    if (this.hasFullProtocolRegex.test(urlMatch)) {\n      stringBeforeSlash = urlMatch.split('://')[1];\n    }\n    return stringBeforeSlash.split('/')[0].indexOf(\"..\") > -1;\n  };\n  /**\r\n   * Determines if the URI scheme is a valid scheme to be autolinked. Returns\r\n   * `false` if the scheme is 'javascript:' or 'vbscript:'\r\n   *\r\n   * @private\r\n   * @param {String} uriSchemeMatch The match URL string for a full URI scheme\r\n   *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.\r\n   * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\r\n   */\n  UrlMatchValidator.isValidUriScheme = function (uriSchemeMatch) {\n    var uriSchemeMatchArr = uriSchemeMatch.match(this.uriSchemeRegex),\n      uriScheme = uriSchemeMatchArr && uriSchemeMatchArr[0].toLowerCase();\n    return uriScheme !== 'javascript:' && uriScheme !== 'vbscript:';\n  };\n  /**\r\n   * Determines if a URL match does not have either:\r\n   *\r\n   * a) a full protocol (i.e. 'http://'), or\r\n   * b) at least one dot ('.') in the domain name (for a non-full-protocol\r\n   *    match).\r\n   *\r\n   * Either situation is considered an invalid URL (ex: 'git:d' does not have\r\n   * either the '://' part, or at least one dot in the domain name. If the\r\n   * match was 'git:abc.com', we would consider this valid.)\r\n   *\r\n   * @private\r\n   * @param {String} urlMatch The matched URL, if there was one. Will be an\r\n   *   empty string if the match is not a URL match.\r\n   * @param {String} protocolUrlMatch The match URL string for a protocol\r\n   *   match. Ex: 'http://yahoo.com'. This is used to match something like\r\n   *   'http://localhost', where we won't double check that the domain name\r\n   *   has at least one '.' in it.\r\n   * @return {Boolean} `true` if the URL match does not have a full protocol,\r\n   *   or at least one dot ('.') in a non-full-protocol match.\r\n   */\n  UrlMatchValidator.urlMatchDoesNotHaveProtocolOrDot = function (urlMatch, protocolUrlMatch) {\n    return !!urlMatch && (!protocolUrlMatch || !this.hasFullProtocolRegex.test(protocolUrlMatch)) && urlMatch.indexOf('.') === -1;\n  };\n  /**\r\n   * Determines if a URL match does not have either:\r\n   *\r\n   * a) a full protocol (i.e. 'http://'), or\r\n   * b) at least one word character after the protocol (i.e. in the domain name)\r\n   *\r\n   * At least one letter character must exist in the domain name after a\r\n   * protocol match. Ex: skip over something like \"git:1.0\"\r\n   *\r\n   * @private\r\n   * @param {String} urlMatch The matched URL, if there was one. Will be an\r\n   *   empty string if the match is not a URL match.\r\n   * @param {String} protocolUrlMatch The match URL string for a protocol\r\n   *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we\r\n   *   have a protocol in the URL string, in order to check for a word\r\n   *   character after the protocol separator (':').\r\n   * @return {Boolean} `true` if the URL match does not have a full protocol, or\r\n   * at least one word character in it, `false` otherwise.\r\n   */\n  UrlMatchValidator.urlMatchDoesNotHaveAtLeastOneWordChar = function (urlMatch, protocolUrlMatch) {\n    if (urlMatch && protocolUrlMatch) {\n      return !this.hasFullProtocolRegex.test(protocolUrlMatch) && !this.hasWordCharAfterProtocolRegex.test(urlMatch);\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'\r\n   *\r\n   * @private\r\n   * @property {RegExp} hasFullProtocolRegex\r\n   */\n  UrlMatchValidator.hasFullProtocolRegex = /^[A-Za-z][-.+A-Za-z0-9]*:\\/\\//;\n  /**\r\n   * Regex to find the URI scheme, such as 'mailto:'.\r\n   *\r\n   * This is used to filter out 'javascript:' and 'vbscript:' schemes.\r\n   *\r\n   * @private\r\n   * @property {RegExp} uriSchemeRegex\r\n   */\n  UrlMatchValidator.uriSchemeRegex = /^[A-Za-z][-.+A-Za-z0-9]*:/;\n  /**\r\n   * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\r\n   *\r\n   * @private\r\n   * @property {RegExp} hasWordCharAfterProtocolRegex\r\n   */\n  UrlMatchValidator.hasWordCharAfterProtocolRegex = new RegExp(\":[^\\\\s]*?[\" + alphaCharsStr + \"]\");\n  /**\r\n   * Regex to determine if the string is a valid IP address\r\n   *\r\n   * @private\r\n   * @property {RegExp} ipRegex\r\n   */\n  UrlMatchValidator.ipRegex = /[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?(:[0-9]*)?\\/?$/;\n  return UrlMatchValidator;\n}();\nexport { UrlMatchValidator };","map":{"version":3,"mappings":"AAAA,SAASA,aAAa,QAAQ,cAAc;AAE5C;;;;;;;;;;;;;;AAcA;EAAA,8BAkKA;EA9HC;;;;;;;;;;;;;;;;;;;;;;;;;;EA0BOC,yBAAO,GAAd,UAAgBC,QAAgB,EAAEC,gBAAwB;IACzD,IACGA,gBAAgB,IAAI,CAAC,IAAI,CAACC,gBAAgB,CAAED,gBAAgB,CAAE,IAChE,IAAI,CAACE,gCAAgC,CAAEH,QAAQ,EAAEC,gBAAgB,CAAE;IAAO;IACzE,IAAI,CAACG,qCAAqC,CAAEJ,QAAQ,EAAEC,gBAAgB,CAAE;IAAI;IAC1E,CAAC,IAAI,CAACI,gBAAgB,CAAEL,QAAQ,CAAG;IAAI;IAC1C,IAAI,CAACM,oBAAoB,CAAEN,QAAQ,CAAE,EACpC;MACD,OAAO,KAAK;;IAGb,OAAO,IAAI;EACZ,CAAC;EAGMD,kCAAgB,GAAvB,UAAyBQ,cAAsB;IAC9C,IAAIC,QAAQ,GAAG,IAAIC,MAAM,CAAE,IAAI,CAACC,oBAAoB,CAACC,MAAM,GAAG,IAAI,CAACC,OAAO,CAACD,MAAM,CAAE;IACnF,IAAIE,SAAS,GAAGN,cAAc,CAACO,KAAK,CAAEN,QAAQ,CAAE;IAEhD,OAAOK,SAAS,KAAK,IAAI;EAC1B,CAAC;EAEcd,sCAAoB,GAAnC,UAAqCC,QAAgB;IACpD,IAAIe,iBAAiB,GAAGf,QAAQ;IAChC,IAAI,IAAI,CAACU,oBAAoB,CAACM,IAAI,CAAChB,QAAQ,CAAC,EAAE;MAC7Ce,iBAAiB,GAAGf,QAAQ,CAACiB,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;;IAE7C,OAAOF,iBAAiB,CAACE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;EAC1D,CAAC;EAED;;;;;;;;;EASOnB,kCAAgB,GAAvB,UAAyBQ,cAAsB;IAC9C,IAAIY,iBAAiB,GAAGZ,cAAc,CAACO,KAAK,CAAE,IAAI,CAACM,cAAc,CAAE;MAC/DP,SAAS,GAAGM,iBAAiB,IAAIA,iBAAiB,CAAE,CAAC,CAAE,CAACE,WAAW,EAAE;IAEzE,OAASR,SAAS,KAAK,aAAa,IAAIA,SAAS,KAAK,WAAW;EAClE,CAAC;EAGD;;;;;;;;;;;;;;;;;;;;;EAqBOd,kDAAgC,GAAvC,UAAyCC,QAAgB,EAAEC,gBAAwB;IAClF,OAAS,CAAC,CAACD,QAAQ,KAAM,CAACC,gBAAgB,IAAI,CAAC,IAAI,CAACS,oBAAoB,CAACM,IAAI,CAAEf,gBAAgB,CAAE,CAAE,IAAID,QAAQ,CAACkB,OAAO,CAAE,GAAG,CAAE,KAAK,CAAC,CAAC;EACtI,CAAC;EAGD;;;;;;;;;;;;;;;;;;;EAmBOnB,uDAAqC,GAA5C,UAA8CC,QAAgB,EAAEC,gBAAwB;IACvF,IAAID,QAAQ,IAAIC,gBAAgB,EAAG;MAClC,OAAO,CAAC,IAAI,CAACS,oBAAoB,CAACM,IAAI,CAAEf,gBAAgB,CAAE,IAAI,CAAC,IAAI,CAACqB,6BAA6B,CAACN,IAAI,CAAEhB,QAAQ,CAAE;KAClH,MAAM;MACN,OAAO,KAAK;;EAEd,CAAC;EA9JD;;;;;;EAMOD,sCAAoB,GAAG,+BAA+B;EAE7D;;;;;;;;EAQOA,gCAAc,GAAG,2BAA2B;EAEnD;;;;;;EAMOA,+CAA6B,GAAG,IAAIU,MAAM,CAAC,YAAY,GAAGX,aAAa,GAAG,GAAG,CAAC;EAErF;;;;;;EAMOC,yBAAO,GAAG,0FAA0F;EAgI5G,wBAAC;CAlKD,EAkKC;SAlKYA,iBAAiB","names":["alphaCharsStr","UrlMatchValidator","urlMatch","protocolUrlMatch","isValidUriScheme","urlMatchDoesNotHaveProtocolOrDot","urlMatchDoesNotHaveAtLeastOneWordChar","isValidIpAddress","containsMultipleDots","uriSchemeMatch","newRegex","RegExp","hasFullProtocolRegex","source","ipRegex","uriScheme","match","stringBeforeSlash","test","split","indexOf","uriSchemeMatchArr","uriSchemeRegex","toLowerCase","hasWordCharAfterProtocolRegex"],"sources":["D:\\github\\editor.io\\node_modules\\autolinker\\dist\\es2015\\src\\matcher\\url-match-validator.ts"],"sourcesContent":["import { alphaCharsStr } from \"../regex-lib\";\n\n/**\n * @private\n * @class Autolinker.matcher.UrlMatchValidator\n * @singleton\n *\n * Used by Autolinker to filter out false URL positives from the\n * {@link Autolinker.matcher.Url UrlMatcher}.\n *\n * Due to the limitations of regular expressions (including the missing feature\n * of look-behinds in JS regular expressions), we cannot always determine the\n * validity of a given match. This class applies a bit of additional logic to\n * filter out any false positives that have been matched by the\n * {@link Autolinker.matcher.Url UrlMatcher}.\n */\nexport class UrlMatchValidator {\n\n\t/**\n\t * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'\n\t *\n\t * @private\n\t * @property {RegExp} hasFullProtocolRegex\n\t */\n\tstatic hasFullProtocolRegex = /^[A-Za-z][-.+A-Za-z0-9]*:\\/\\//;\n\n\t/**\n\t * Regex to find the URI scheme, such as 'mailto:'.\n\t *\n\t * This is used to filter out 'javascript:' and 'vbscript:' schemes.\n\t *\n\t * @private\n\t * @property {RegExp} uriSchemeRegex\n\t */\n\tstatic uriSchemeRegex = /^[A-Za-z][-.+A-Za-z0-9]*:/;\n\n\t/**\n\t * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\n\t *\n\t * @private\n\t * @property {RegExp} hasWordCharAfterProtocolRegex\n\t */\n\tstatic hasWordCharAfterProtocolRegex = new RegExp(\":[^\\\\s]*?[\" + alphaCharsStr + \"]\");\n\n\t/**\n\t * Regex to determine if the string is a valid IP address\n\t *\n\t * @private\n\t * @property {RegExp} ipRegex\n\t */\n\tstatic ipRegex = /[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?(:[0-9]*)?\\/?$/;\n\n\t/**\n\t * Determines if a given URL match found by the {@link Autolinker.matcher.Url UrlMatcher}\n\t * is valid. Will return `false` for:\n\t *\n\t * 1) URL matches which do not have at least have one period ('.') in the\n\t *    domain name (effectively skipping over matches like \"abc:def\").\n\t *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')\n\t * 2) URL matches which do not have at least one word character in the\n\t *    domain name (effectively skipping over matches like \"git:1.0\").\n\t *    However, URL matches with a protocol will be allowed (ex: 'intra-net://271219.76')\n\t * 3) A protocol-relative url match (a URL beginning with '//') whose\n\t *    previous character is a word character (effectively skipping over\n\t *    strings like \"abc//google.com\")\n\t *\n\t * Otherwise, returns `true`.\n\t *\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http://yahoo.com'. This is used to match something like\n\t *   'http://localhost', where we won't double check that the domain name\n\t *   has at least one '.' in it.\n\t * @return {Boolean} `true` if the match given is valid and should be\n\t *   processed, or `false` if the match is invalid and/or should just not be\n\t *   processed.\n\t */\n\tstatic isValid( urlMatch: string, protocolUrlMatch: string ) {\n\t\tif(\n\t\t\t( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||\n\t\t\tthis.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||    // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n\t\t\t(this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) && // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n\t\t\t   !this.isValidIpAddress( urlMatch )) || // Except if it's an IP address\n\t\t\tthis.containsMultipleDots( urlMatch )\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\tstatic isValidIpAddress( uriSchemeMatch: string ) {\n\t\tlet newRegex = new RegExp( this.hasFullProtocolRegex.source + this.ipRegex.source );\n\t\tlet uriScheme = uriSchemeMatch.match( newRegex );\n\n\t\treturn uriScheme !== null;\n\t}\n\n\tprivate static containsMultipleDots( urlMatch: string ) {\n\t\tvar stringBeforeSlash = urlMatch;\n\t\tif (this.hasFullProtocolRegex.test(urlMatch)) {\n\t\t\tstringBeforeSlash = urlMatch.split('://')[1];\n\t\t}\n\t\treturn stringBeforeSlash.split('/')[0].indexOf(\"..\") > -1;\n\t}\n\n\t/**\n\t * Determines if the URI scheme is a valid scheme to be autolinked. Returns\n\t * `false` if the scheme is 'javascript:' or 'vbscript:'\n\t *\n\t * @private\n\t * @param {String} uriSchemeMatch The match URL string for a full URI scheme\n\t *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.\n\t * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\n\t */\n\tstatic isValidUriScheme( uriSchemeMatch: string ) {\n\t\tlet uriSchemeMatchArr = uriSchemeMatch.match( this.uriSchemeRegex ),\n\t\t    uriScheme = uriSchemeMatchArr && uriSchemeMatchArr[ 0 ].toLowerCase();\n\n\t\treturn ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );\n\t}\n\n\n\t/**\n\t * Determines if a URL match does not have either:\n\t *\n\t * a) a full protocol (i.e. 'http://'), or\n\t * b) at least one dot ('.') in the domain name (for a non-full-protocol\n\t *    match).\n\t *\n\t * Either situation is considered an invalid URL (ex: 'git:d' does not have\n\t * either the '://' part, or at least one dot in the domain name. If the\n\t * match was 'git:abc.com', we would consider this valid.)\n\t *\n\t * @private\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http://yahoo.com'. This is used to match something like\n\t *   'http://localhost', where we won't double check that the domain name\n\t *   has at least one '.' in it.\n\t * @return {Boolean} `true` if the URL match does not have a full protocol,\n\t *   or at least one dot ('.') in a non-full-protocol match.\n\t */\n\tstatic urlMatchDoesNotHaveProtocolOrDot( urlMatch: string, protocolUrlMatch: string ) {\n\t\treturn ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );\n\t}\n\n\n\t/**\n\t * Determines if a URL match does not have either:\n\t *\n\t * a) a full protocol (i.e. 'http://'), or\n\t * b) at least one word character after the protocol (i.e. in the domain name)\n\t *\n\t * At least one letter character must exist in the domain name after a\n\t * protocol match. Ex: skip over something like \"git:1.0\"\n\t *\n\t * @private\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we\n\t *   have a protocol in the URL string, in order to check for a word\n\t *   character after the protocol separator (':').\n\t * @return {Boolean} `true` if the URL match does not have a full protocol, or\n\t * at least one word character in it, `false` otherwise.\n\t */\n\tstatic urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch: string, protocolUrlMatch: string ) {\n\t\tif( urlMatch && protocolUrlMatch ) {\n\t\t\treturn !this.hasFullProtocolRegex.test( protocolUrlMatch ) && !this.hasWordCharAfterProtocolRegex.test( urlMatch );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}