{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Matcher } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr, domainNameCharRegex } from \"../regex-lib\";\nimport { EmailMatch } from \"../match/email-match\";\nimport { throwUnhandledCaseError } from '../utils';\nimport { tldRegex } from \"./tld-regex\";\n// For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\n// RegExp objects which are shared by all instances of EmailMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating EmailMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\nvar localPartCharRegex = new RegExp(\"[\" + alphaNumericAndMarksCharsStr + \"!#$%&'*+/=?^_`{|}~-]\");\nvar strictTldRegex = new RegExp(\"^\" + tldRegex.source + \"$\");\n/**\r\n * @class Autolinker.matcher.Email\r\n * @extends Autolinker.matcher.Matcher\r\n *\r\n * Matcher to find email matches in an input string.\r\n *\r\n * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\r\n */\nvar EmailMatcher = /** @class */function (_super) {\n  tslib_1.__extends(EmailMatcher, _super);\n  function EmailMatcher() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Valid characters that can be used in the \"local\" part of an email address,\r\n     * i.e. the \"name\" part of \"name@site.com\"\r\n     */\n    _this.localPartCharRegex = localPartCharRegex;\n    /**\r\n     * Stricter TLD regex which adds a beginning and end check to ensure\r\n     * the string is a valid TLD\r\n     */\n    _this.strictTldRegex = strictTldRegex;\n    return _this;\n  }\n  /**\r\n   * @inheritdoc\r\n   */\n  EmailMatcher.prototype.parseMatches = function (text) {\n    var tagBuilder = this.tagBuilder,\n      localPartCharRegex = this.localPartCharRegex,\n      strictTldRegex = this.strictTldRegex,\n      matches = [],\n      len = text.length,\n      noCurrentEmailMatch = new CurrentEmailMatch();\n    // for matching a 'mailto:' prefix\n    var mailtoTransitions = {\n      'm': 'a',\n      'a': 'i',\n      'i': 'l',\n      'l': 't',\n      't': 'o',\n      'o': ':'\n    };\n    var charIdx = 0,\n      state = 0 /* NonEmailMatch */,\n      currentEmailMatch = noCurrentEmailMatch;\n    // For debugging: search for other \"For debugging\" lines\n    // const table = new CliTable( {\n    // \thead: [ 'charIdx', 'char', 'state', 'charIdx', 'currentEmailAddress.idx', 'hasDomainDot' ]\n    // } );\n    while (charIdx < len) {\n      var char = text.charAt(charIdx);\n      // For debugging: search for other \"For debugging\" lines\n      // table.push( \n      // \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n      // );\n      switch (state) {\n        case 0 /* NonEmailMatch */:\n          stateNonEmailAddress(char);\n          break;\n        case 1 /* Mailto */:\n          stateMailTo(text.charAt(charIdx - 1), char);\n          break;\n        case 2 /* LocalPart */:\n          stateLocalPart(char);\n          break;\n        case 3 /* LocalPartDot */:\n          stateLocalPartDot(char);\n          break;\n        case 4 /* AtSign */:\n          stateAtSign(char);\n          break;\n        case 5 /* DomainChar */:\n          stateDomainChar(char);\n          break;\n        case 6 /* DomainHyphen */:\n          stateDomainHyphen(char);\n          break;\n        case 7 /* DomainDot */:\n          stateDomainDot(char);\n          break;\n        default:\n          throwUnhandledCaseError(state);\n      }\n      // For debugging: search for other \"For debugging\" lines\n      // table.push( \n      // \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n      // );\n      charIdx++;\n    }\n    // Capture any valid match at the end of the string\n    captureMatchIfValidAndReset();\n    // For debugging: search for other \"For debugging\" lines\n    //console.log( '\\n' + table.toString() );\n    return matches;\n    // Handles the state when we're not in an email address\n    function stateNonEmailAddress(char) {\n      if (char === 'm') {\n        beginEmailMatch(1 /* Mailto */);\n      } else if (localPartCharRegex.test(char)) {\n        beginEmailMatch();\n      } else {\n        // not an email address character, continue\n      }\n    }\n    // Handles if we're reading a 'mailto:' prefix on the string\n    function stateMailTo(prevChar, char) {\n      if (prevChar === ':') {\n        // We've reached the end of the 'mailto:' prefix\n        if (localPartCharRegex.test(char)) {\n          state = 2 /* LocalPart */;\n          currentEmailMatch = new CurrentEmailMatch(tslib_1.__assign({}, currentEmailMatch, {\n            hasMailtoPrefix: true\n          }));\n        } else {\n          // we've matched 'mailto:' but didn't get anything meaningful\n          // immediately afterwards (for example, we encountered a \n          // space character, or an '@' character which formed 'mailto:@'\n          resetToNonEmailMatchState();\n        }\n      } else if (mailtoTransitions[prevChar] === char) {\n        // We're currently reading the 'mailto:' prefix, stay in\n        // Mailto state\n      } else if (localPartCharRegex.test(char)) {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // different character that didn't continue the prefix\n        state = 2 /* LocalPart */;\n      } else if (char === '.') {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // dot character\n        state = 3 /* LocalPartDot */;\n      } else if (char === '@') {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // an @ character\n        state = 4 /* AtSign */;\n      } else {\n        // not an email address character, return to \"NonEmailAddress\" state\n        resetToNonEmailMatchState();\n      }\n    }\n    // Handles the state when we're currently in the \"local part\" of an \n    // email address (as opposed to the \"domain part\")\n    function stateLocalPart(char) {\n      if (char === '.') {\n        state = 3 /* LocalPartDot */;\n      } else if (char === '@') {\n        state = 4 /* AtSign */;\n      } else if (localPartCharRegex.test(char)) {\n        // stay in the \"local part\" of the email address\n      } else {\n        // not an email address character, return to \"NonEmailAddress\" state\n        resetToNonEmailMatchState();\n      }\n    }\n    // Handles the state where we've read \n    function stateLocalPartDot(char) {\n      if (char === '.') {\n        // We read a second '.' in a row, not a valid email address \n        // local part\n        resetToNonEmailMatchState();\n      } else if (char === '@') {\n        // We read the '@' character immediately after a dot ('.'), not \n        // an email address\n        resetToNonEmailMatchState();\n      } else if (localPartCharRegex.test(char)) {\n        state = 2 /* LocalPart */;\n      } else {\n        // Anything else, not an email address\n        resetToNonEmailMatchState();\n      }\n    }\n    function stateAtSign(char) {\n      if (domainNameCharRegex.test(char)) {\n        state = 5 /* DomainChar */;\n      } else {\n        // Anything else, not an email address\n        resetToNonEmailMatchState();\n      }\n    }\n    function stateDomainChar(char) {\n      if (char === '.') {\n        state = 7 /* DomainDot */;\n      } else if (char === '-') {\n        state = 6 /* DomainHyphen */;\n      } else if (domainNameCharRegex.test(char)) {\n        // Stay in the DomainChar state\n      } else {\n        // Anything else, we potentially matched if the criteria has\n        // been met\n        captureMatchIfValidAndReset();\n      }\n    }\n    function stateDomainHyphen(char) {\n      if (char === '-' || char === '.') {\n        // Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n        captureMatchIfValidAndReset();\n      } else if (domainNameCharRegex.test(char)) {\n        state = 5 /* DomainChar */;\n      } else {\n        // Anything else\n        captureMatchIfValidAndReset();\n      }\n    }\n    function stateDomainDot(char) {\n      if (char === '.' || char === '-') {\n        // not valid to have two dots (\"..\") or dot+hypen (\".-\")\n        captureMatchIfValidAndReset();\n      } else if (domainNameCharRegex.test(char)) {\n        state = 5 /* DomainChar */;\n        // After having read a '.' and then a valid domain character,\n        // we now know that the domain part of the email is valid, and\n        // we have found at least a partial EmailMatch (however, the\n        // email address may have additional characters from this point)\n        currentEmailMatch = new CurrentEmailMatch(tslib_1.__assign({}, currentEmailMatch, {\n          hasDomainDot: true\n        }));\n      } else {\n        // Anything else\n        captureMatchIfValidAndReset();\n      }\n    }\n    function beginEmailMatch(newState) {\n      if (newState === void 0) {\n        newState = 2 /* LocalPart */;\n      }\n      state = newState;\n      currentEmailMatch = new CurrentEmailMatch({\n        idx: charIdx\n      });\n    }\n    function resetToNonEmailMatchState() {\n      state = 0 /* NonEmailMatch */;\n      currentEmailMatch = noCurrentEmailMatch;\n    }\n    /*\r\n     * Captures the current email address as an EmailMatch if it's valid,\r\n     * and resets the state to read another email address.\r\n     */\n    function captureMatchIfValidAndReset() {\n      if (currentEmailMatch.hasDomainDot) {\n        // we need at least one dot in the domain to be considered a valid email address\n        var matchedText = text.slice(currentEmailMatch.idx, charIdx);\n        // If we read a '.' or '-' char that ended the email address\n        // (valid domain name characters, but only valid email address\n        // characters if they are followed by something else), strip \n        // it off now\n        if (/[-.]$/.test(matchedText)) {\n          matchedText = matchedText.slice(0, -1);\n        }\n        var emailAddress = currentEmailMatch.hasMailtoPrefix ? matchedText.slice('mailto:'.length) : matchedText;\n        // if the email address has a valid TLD, add it to the list of matches\n        if (doesEmailHaveValidTld(emailAddress)) {\n          matches.push(new EmailMatch({\n            tagBuilder: tagBuilder,\n            matchedText: matchedText,\n            offset: currentEmailMatch.idx,\n            email: emailAddress\n          }));\n        }\n      }\n      resetToNonEmailMatchState();\n      /**\r\n       * Determines if the given email address has a valid TLD or not\r\n       * @param {string} emailAddress - email address\r\n       * @return {Boolean} - true is email have valid TLD, false otherwise\r\n       */\n      function doesEmailHaveValidTld(emailAddress) {\n        var emailAddressTld = emailAddress.split('.').pop() || '';\n        var emailAddressNormalized = emailAddressTld.toLowerCase();\n        var isValidTld = strictTldRegex.test(emailAddressNormalized);\n        return isValidTld;\n      }\n    }\n  };\n  return EmailMatcher;\n}(Matcher);\nexport { EmailMatcher };\nvar CurrentEmailMatch = /** @class */function () {\n  function CurrentEmailMatch(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    this.idx = cfg.idx !== undefined ? cfg.idx : -1;\n    this.hasMailtoPrefix = !!cfg.hasMailtoPrefix;\n    this.hasDomainDot = !!cfg.hasDomainDot;\n  }\n  return CurrentEmailMatch;\n}();","map":{"version":3,"mappings":"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","names":["Matcher","alphaNumericAndMarksCharsStr","domainNameCharRegex","EmailMatch","throwUnhandledCaseError","tldRegex","localPartCharRegex","RegExp","strictTldRegex","source","tslib_1","_this","EmailMatcher","text","tagBuilder","matches","len","length","noCurrentEmailMatch","CurrentEmailMatch","mailtoTransitions","charIdx","state","currentEmailMatch","char","charAt","stateNonEmailAddress","stateMailTo","stateLocalPart","stateLocalPartDot","stateAtSign","stateDomainChar","stateDomainHyphen","stateDomainDot","captureMatchIfValidAndReset","beginEmailMatch","test","prevChar","hasMailtoPrefix","resetToNonEmailMatchState","hasDomainDot","newState","idx","matchedText","slice","emailAddress","doesEmailHaveValidTld","push","offset","email","emailAddressTld","split","pop","emailAddressNormalized","toLowerCase","isValidTld","cfg","undefined"],"sources":["D:\\github\\editor.io\\node_modules\\autolinker\\dist\\es2015\\src\\matcher\\email-matcher.ts"],"sourcesContent":["import { Matcher } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr, domainNameCharRegex } from \"../regex-lib\";\nimport { EmailMatch } from \"../match/email-match\";\nimport { Match } from \"../match/match\";\nimport { throwUnhandledCaseError } from '../utils';\nimport { tldRegex } from \"./tld-regex\";\n\n// For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\n\n// RegExp objects which are shared by all instances of EmailMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating EmailMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\nconst localPartCharRegex = new RegExp( `[${alphaNumericAndMarksCharsStr}!#$%&'*+/=?^_\\`{|}~-]` );\nconst strictTldRegex = new RegExp( `^${tldRegex.source}$` );\n\n/**\n * @class Autolinker.matcher.Email\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find email matches in an input string.\n *\n * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\n */\nexport class EmailMatcher extends Matcher {\n\n\t/**\n\t * Valid characters that can be used in the \"local\" part of an email address,\n\t * i.e. the \"name\" part of \"name@site.com\"\n\t */\n\tprotected localPartCharRegex = localPartCharRegex;\n\n\t/**\n\t * Stricter TLD regex which adds a beginning and end check to ensure\n\t * the string is a valid TLD\n\t */\n\tprotected strictTldRegex = strictTldRegex;\n\n\n\t/**\n\t * @inheritdoc\n\t */\n\tparseMatches( text: string ) {\n\t\tconst tagBuilder = this.tagBuilder,\n\t\t\t  localPartCharRegex = this.localPartCharRegex,\n\t\t\t  strictTldRegex = this.strictTldRegex,\n\t\t\t  matches: Match[] = [],\n\t\t\t  len = text.length,\n\t\t\t  noCurrentEmailMatch = new CurrentEmailMatch();\n\n\t\t// for matching a 'mailto:' prefix\n\t\tconst mailtoTransitions = {\n\t\t\t'm': 'a',\n\t\t\t'a': 'i',\n\t\t\t'i': 'l',\n\t\t\t'l': 't',\n\t\t\t't': 'o',\n\t\t\t'o': ':',\n\t\t};\n\n\t\tlet charIdx = 0,\n\t\t\tstate = State.NonEmailMatch as State,\n\t\t\tcurrentEmailMatch = noCurrentEmailMatch;\n\n\t\t// For debugging: search for other \"For debugging\" lines\n\t\t// const table = new CliTable( {\n\t\t// \thead: [ 'charIdx', 'char', 'state', 'charIdx', 'currentEmailAddress.idx', 'hasDomainDot' ]\n\t\t// } );\n\n\t\twhile( charIdx < len ) {\n\t\t\tconst char = text.charAt( charIdx );\n\n\t\t\t// For debugging: search for other \"For debugging\" lines\n\t\t\t// table.push( \n\t\t\t// \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n\t\t\t// );\n\n\t\t\tswitch( state ) {\n\t\t\t\tcase State.NonEmailMatch: stateNonEmailAddress( char ); break;\n\n\t\t\t\tcase State.Mailto: \n\t\t\t\t\tstateMailTo( text.charAt( charIdx - 1 ) as MailtoChar, char ); \n\t\t\t\t\tbreak;\n\t\t\t\tcase State.LocalPart: stateLocalPart( char ); break;\n\t\t\t\tcase State.LocalPartDot: stateLocalPartDot( char ); break;\n\t\t\t\tcase State.AtSign: stateAtSign( char ); break;\n\t\t\t\tcase State.DomainChar: stateDomainChar( char ); break;\n\t\t\t\tcase State.DomainHyphen: stateDomainHyphen( char ); break;\n\t\t\t\tcase State.DomainDot: stateDomainDot( char ); break;\n\t\n\t\t\t\tdefault: \n\t\t\t\t\tthrowUnhandledCaseError( state );\n\t\t\t}\n\n\t\t\t// For debugging: search for other \"For debugging\" lines\n\t\t\t// table.push( \n\t\t\t// \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n\t\t\t// );\n\n\t\t\tcharIdx++;\n\t\t}\n\n\t\t// Capture any valid match at the end of the string\n\t\tcaptureMatchIfValidAndReset();\n\n\t\t// For debugging: search for other \"For debugging\" lines\n\t\t//console.log( '\\n' + table.toString() );\n\t\t\n\t\treturn matches;\n\n\n\t\t// Handles the state when we're not in an email address\n\t\tfunction stateNonEmailAddress( char: string ) {\n\t\t\tif( char === 'm' ) {\n\t\t\t\tbeginEmailMatch( State.Mailto );\n\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\tbeginEmailMatch();\n\n\t\t\t} else {\n\t\t\t\t// not an email address character, continue\n\t\t\t}\n\t\t}\n\n\n\t\t// Handles if we're reading a 'mailto:' prefix on the string\n\t\tfunction stateMailTo( prevChar: MailtoChar, char: string ) {\n\t\t\tif( prevChar === ':' ) {\n\t\t\t\t// We've reached the end of the 'mailto:' prefix\n\t\t\t\tif( localPartCharRegex.test( char ) ) {\n\t\t\t\t\tstate = State.LocalPart;\n\t\t\t\t\tcurrentEmailMatch = new CurrentEmailMatch( { \n\t\t\t\t\t\t...currentEmailMatch, \n\t\t\t\t\t\thasMailtoPrefix: true \n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\t// we've matched 'mailto:' but didn't get anything meaningful\n\t\t\t\t\t// immediately afterwards (for example, we encountered a \n\t\t\t\t\t// space character, or an '@' character which formed 'mailto:@'\n\t\t\t\t\tresetToNonEmailMatchState();\n\t\t\t\t}\n\n\t\t\t} else if( mailtoTransitions[ prevChar ] === char ) {\n\t\t\t\t// We're currently reading the 'mailto:' prefix, stay in\n\t\t\t\t// Mailto state\n\t\t\t\t\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\t// We we're reading a prefix of 'mailto:', but encountered a\n\t\t\t\t// different character that didn't continue the prefix\n\t\t\t\tstate = State.LocalPart;\n\n\t\t\t} else if( char === '.' ) {\n\t\t\t\t// We we're reading a prefix of 'mailto:', but encountered a\n\t\t\t\t// dot character\n\t\t\t\tstate = State.LocalPartDot;\n\n\t\t\t} else if( char === '@' ) {\n\t\t\t\t// We we're reading a prefix of 'mailto:', but encountered a\n\t\t\t\t// an @ character\n\t\t\t\tstate = State.AtSign;\n\n\t\t\t} else {\n\t\t\t\t// not an email address character, return to \"NonEmailAddress\" state\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\n\t\t// Handles the state when we're currently in the \"local part\" of an \n\t\t// email address (as opposed to the \"domain part\")\n\t\tfunction stateLocalPart( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\tstate = State.LocalPartDot;\n\n\t\t\t} else if( char === '@' ) {\n\t\t\t\tstate = State.AtSign;\n\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\t// stay in the \"local part\" of the email address\n\n\t\t\t} else {\n\t\t\t\t// not an email address character, return to \"NonEmailAddress\" state\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\n\t\t// Handles the state where we've read \n\t\tfunction stateLocalPartDot( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\t// We read a second '.' in a row, not a valid email address \n\t\t\t\t// local part\n\t\t\t\tresetToNonEmailMatchState();\n\n\t\t\t} else if( char === '@' ) {\n\t\t\t\t// We read the '@' character immediately after a dot ('.'), not \n\t\t\t\t// an email address\n\t\t\t\tresetToNonEmailMatchState();\n\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\tstate = State.LocalPart;\n\n\t\t\t} else {\n\t\t\t\t// Anything else, not an email address\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\n\t\tfunction stateAtSign( char: string ) {\n\t\t\tif( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t} else {\n\t\t\t\t// Anything else, not an email address\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainChar( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\tstate = State.DomainDot;\n\n\t\t\t} else if( char === '-' ) {\n\t\t\t\tstate = State.DomainHyphen;\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\t// Stay in the DomainChar state\n\n\t\t\t} else {\n\t\t\t\t// Anything else, we potentially matched if the criteria has\n\t\t\t\t// been met\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainHyphen( char: string ) {\n\t\t\tif( char === '-' || char === '.' ) {\n\t\t\t\t// Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n\t\t\t\tcaptureMatchIfValidAndReset();\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t} else {\n\t\t\t\t// Anything else\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainDot( char: string ) {\n\t\t\tif( char === '.' || char === '-' ) {\n\t\t\t\t// not valid to have two dots (\"..\") or dot+hypen (\".-\")\n\t\t\t\tcaptureMatchIfValidAndReset();\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t\t// After having read a '.' and then a valid domain character,\n\t\t\t\t// we now know that the domain part of the email is valid, and\n\t\t\t\t// we have found at least a partial EmailMatch (however, the\n\t\t\t\t// email address may have additional characters from this point)\n\t\t\t\tcurrentEmailMatch = new CurrentEmailMatch( { \n\t\t\t\t\t...currentEmailMatch, \n\t\t\t\t\thasDomainDot: true \n\t\t\t\t} );\n\n\t\t\t} else {\n\t\t\t\t// Anything else\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\n\t\tfunction beginEmailMatch( newState = State.LocalPart ) {\n\t\t\tstate = newState;\n\t\t\tcurrentEmailMatch = new CurrentEmailMatch( { idx: charIdx } );\n\t\t}\n\n\t\tfunction resetToNonEmailMatchState() {\n\t\t\tstate = State.NonEmailMatch;\n\t\t\tcurrentEmailMatch = noCurrentEmailMatch;\n\t\t}\n\n\n\n\t\t/*\n\t\t * Captures the current email address as an EmailMatch if it's valid,\n\t\t * and resets the state to read another email address.\n\t\t */\n\t\tfunction captureMatchIfValidAndReset() {\n\t\t\tif( currentEmailMatch.hasDomainDot ) {  // we need at least one dot in the domain to be considered a valid email address\n\t\t\t\tlet matchedText = text.slice( currentEmailMatch.idx, charIdx );\n\n\t\t\t\t// If we read a '.' or '-' char that ended the email address\n\t\t\t\t// (valid domain name characters, but only valid email address\n\t\t\t\t// characters if they are followed by something else), strip \n\t\t\t\t// it off now\n\t\t\t\tif( /[-.]$/.test( matchedText ) ){\n\t\t\t\t\tmatchedText = matchedText.slice( 0, -1 );\n\t\t\t\t}\n\n\t\t\t\tconst emailAddress = currentEmailMatch.hasMailtoPrefix \n\t\t\t\t\t? matchedText.slice( 'mailto:'.length ) \n\t\t\t\t\t: matchedText;\n\n\t\t\t\t// if the email address has a valid TLD, add it to the list of matches\n\t\t\t\tif ( doesEmailHaveValidTld( emailAddress ) ) {\n\t\t\t\t\tmatches.push( new EmailMatch( {\n\t\t\t\t\t\ttagBuilder  : tagBuilder,\n\t\t\t\t\t\tmatchedText : matchedText,\n\t\t\t\t\t\toffset      : currentEmailMatch.idx,\n\t\t\t\t\t\temail       : emailAddress\n\t\t\t\t\t} ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresetToNonEmailMatchState();\n\t\t\n\n\t\t/**\n\t\t * Determines if the given email address has a valid TLD or not\n\t\t * @param {string} emailAddress - email address\n\t\t * @return {Boolean} - true is email have valid TLD, false otherwise\n\t\t */\n\t\tfunction doesEmailHaveValidTld( emailAddress: string ) {\n\t\t\tconst emailAddressTld : string = emailAddress.split( '.' ).pop() || '';\n\t\t\tconst emailAddressNormalized = emailAddressTld.toLowerCase();\n\t\t\tconst isValidTld = strictTldRegex.test( emailAddressNormalized );\n\n\t\t\treturn isValidTld;\n\t\t}}\n\t}\n\n}\n\ntype MailtoChar = 'm' | 'a' | 'i' | 'l' | 't' | 'o' | ':';\n\nconst enum State {\n\tNonEmailMatch = 0,\n\t\n\tMailto,  // if matching a 'mailto:' prefix\n\tLocalPart,\n\tLocalPartDot,\n\tAtSign,\n\tDomainChar,\n\tDomainHyphen,\n\tDomainDot\n}\n\nclass CurrentEmailMatch {\n\treadonly idx: number;  // the index of the first character in the email address\n\treadonly hasMailtoPrefix: boolean;\n\treadonly hasDomainDot: boolean;\n\n\tconstructor( cfg: Partial<CurrentEmailMatch> = {} ) {\n\t\tthis.idx = cfg.idx !== undefined ? cfg.idx : -1;\n\t\tthis.hasMailtoPrefix = !!cfg.hasMailtoPrefix;\n\t\tthis.hasDomainDot = !!cfg.hasDomainDot;\n\t}\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}